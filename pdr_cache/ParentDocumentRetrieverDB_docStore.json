{
  "130a189a851990aef3cf054076f1e11c": {
    "page_content": "问：讲讲输入URL到网页显示发生什么？ 答：当你在浏览器中输入一个 URL 并回车，浏览器首先通过 DNS 将域名解析为服务器的 IP 地址。随后，它与服务器建立 TCP 连接（如果是 HTTPS，还需进行 TLS 握手以加密通信）。连接建立后，浏览器发送 HTTP 请求，服务器接收请求后处理业务逻辑并返回响应内容（如 HTML 页面）。浏览器接收响应后开始渲染页面：解析 HTML、CSS 和 JS，构建渲染树，绘制内容并展示给用户。整个过程涉及网络通信、协议交互和前端渲染等多个环节，协同完成网页的呈现。\n问：把我当做小白，用大白话给我讲讲计算机网络体系是怎么工作的？\n答：计算机网络体系就像寄快递一样分层协作：你说的话在应用层，像聊天、看网页；传输层负责把这些内容打包好，保证安全送达；网络层决定走哪条路（像导航）；数据链路层负责每一跳的搬运（像快递车送到中转站）；物理层就是电线、光纤，把0和1的信号真正送出去。每一层各司其职，最终把信息从你电脑送到别人的电脑上。\n问：面向对象和面向过程的区别？\n答：面向过程是以“过程”为中心，强调一步步执行的逻辑，像做菜时照着菜谱一步步来；而面向对象是以“对象”为中心，把数据和功能封装在一起，像把厨师、食材和工具都当作一个个对象来协作完成做菜任务。前者关注“怎么做”，后者关注“谁来做”。",
    "metadata": {
      "source": "F:\\Python\\PaperTask\\files\\examples.txt"
    }
  },
  "b95f297a90d1ccf0ed67d49fdbd5ef87": {
    "page_content": "问：String 为什么不可变？ 答：Java 中的 String 是不可变的（immutable），是因为它在内存中一旦创建就不能修改，修改其实是创建了新的字符串对象。这种设计有几个重要原因： ① 安全性：比如在网络传输、数据库连接等场景下，字符串不可变可以防止被恶意修改； ② 线程安全：不可变的对象天生线程安全，多线程中可以放心共享； ③ 性能优化：字符串常量池复用字符串，节省内存，只有不可变才安全； ④ 可作为哈希键：因为内容不会变，适合做 HashMap 的 key，提高效率。 所以，String 的不可变性不是限制，而是一种为了安全、性能和稳定性的优化设计。\n问：运行时异常和非运行时异常（checked）的区别？ 答：在 Java 中，运行时异常（RuntimeException） 和 非运行时异常（Checked Exception） 的主要区别在于：编译器是否强制你处理异常。 运行时异常通常是程序逻辑错误引起的，比如空指针、类型转换错误、数组越界等，编译器不会强制你去 try-catch，它们在运行期间可能突然爆发；而非运行时异常是程序正常运行中可能发生但可以预见的问题，如文件找不到、网络中断、数据库异常等，编译器必须强制你捕获或声明抛出。这种设计的目的是让你在写代码时提前意识到外部风险并做出处理，而运行时异常则认为是你自己写错了，Java 把责任交给开发者自己判断是否要处理。",
    "metadata": {
      "source": "F:\\Python\\PaperTask\\files\\examples.txt"
    }
  },
  "631bdc0be81f76e4a96c4f1213d97948": {
    "page_content": "问：说说类实例化的顺序 答：在 Java 中，类的实例化顺序遵循“类 → 对象 → 构造方法”这三大阶段，具体执行顺序如下： 1. 父类静态代码块和静态变量最先执行（只执行一次）； 2. 子类静态代码块和静态变量随后执行（只执行一次）； 然后开始实例化对象： 3. 父类的实例变量初始化和构造代码块先执行； 4. 父类构造方法接着执行； 5. 子类的实例变量初始化和构造代码块随后执行； 6. 子类构造方法最后执行。 总结就是：静态的先执行（类加载时），然后按继承链从父到子初始化和构造对象，这一流程保证了父类先完成准备，子类才能在其基础上构建自己的部分。",
    "metadata": {
      "source": "F:\\Python\\PaperTask\\files\\examples.txt"
    }
  }
}